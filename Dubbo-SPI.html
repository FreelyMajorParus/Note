
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<link rel="stylesheet" href="pluginAssets/katex/katex.css"><script type="application/javascript" src="pluginAssets/mermaid/mermaid.min.js"></script><script type="application/javascript" src="pluginAssets/mermaid/mermaid_render.js"></script><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>Dubbo的扩展点</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">Dubbo的扩展点</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		strong {
			color: #000000;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}
		::-webkit-scrollbar {
			width: 7px;
			height: 7px;
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(100, 100, 100, 0.3); 
			border-radius: 5px;
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(100, 100, 100, 0.7); 
		}

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: .65em;
		}
		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}
		.resource-icon {
			display: inline-block;
			position: relative;
			top: .5em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to precvent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: .7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		.not-loaded-resource img {
			width: 1.15em;
			height: 1.15em;
			background: white;
			padding: 2px !important;
			border-radius: 2px;
			box-shadow: 0 1px 3px #000000aa;
		}

		a.not-loaded-resource img {
			margin-right: .2em;
		}

		a.not-loaded-resource {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 100vh;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}
.mermaid { background-color: white; width: 640px; }</style><div id="rendered-md"><nav class="table-of-contents"><ul><li><a href="#从服务发布开始">从服务发布开始</a></li><li><a href="#什么扩展点">什么扩展点</a><ul><li><a href="#初步的疑问">初步的疑问？</a></li></ul></li><li><a href="#dubbo扩展点分类">Dubbo扩展点分类</a><ul><li><a href="#指定名字扩展">指定名字扩展</a><ul><li><a href="#实例">实例</a></li><li><a href="#原理">原理</a></li><li><a href="#获取extensionloader">获取ExtensionLoader</a></li><li><a href="#获取指定名称扩展">获取指定名称扩展</a></li><li><a href="#加载所有扩展点">加载所有扩展点</a><ul><li><a href="#各个策略strategy下加载扩展类">各个策略(Strategy)下加载扩展类</a></li><li><a href="#extionsion注入内部扩展">Extionsion注入内部扩展</a></li><li><a href="#extensionfactory是什么">ExtensionFactory是什么？</a></li><li><a href="#extension-包装">Extension 包装</a></li></ul></li></ul></li><li><a href="#自适应扩展">自适应扩展</a><ul><li><a href="#loadbalance自适应扩展-方法注解实现">LoadBalance自适应扩展-方法注解实现</a></li><li><a href="#protocol自适应扩展-方法注解实现">Protocol自适应扩展-方法注解实现</a></li><li><a href="#adaptivecompiler自适应扩展-类注解实现">AdaptiveCompiler自适应扩展-类注解实现</a></li></ul></li><li><a href="#扩展点激活activate">扩展点激活@Activate</a><ul><li><a href="#原理-2">原理</a></li><li><a href="#源码分析">源码分析</a></li></ul></li></ul></li><li><a href="#dubbo扩展点实例">Dubbo扩展点实例</a></li><li><a href="#如何自己去实现一个扩展点">如何自己去实现一个扩展点？</a></li><li><a href="#本质上的作用是什么">本质上的作用是什么？</a></li><li><a href="#总结">总结</a></li></ul></nav><h2 id="从服务发布开始">从服务发布开始</h2>
<p>服务发布阶段，当构造出URL时，涉及到如下代码:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).hasExtension(url.getProtocol())</pre><pre class="hljs"><code>ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).hasExtension(url.getProtocol())</code></pre></div>
<h2 id="什么扩展点">什么扩展点</h2>
<p>Dubbo所谓的扩展点就是提供接口(对某块领域做抽象实现，例如协议、负载均衡等)，让开发人员可以实现该抽象接口(或者选择Dubbo内部提供的多种实现/internal/xx)，每个实现对应一个自定义的名称，并且在最终使用过程中，动态的选择自定义名称相对应的实现。Dubbo的扩展点分为3类，第一类是通过名字来获取扩展点，该扩展点的名字以及实现由开发人员自己实现，相当于通过一个Code从一个容器中拿到对应的自定义实现。第二类是自适应的扩展，该扩展就是为了从传递过来的URL参数中解析出对应的参数的值，例如协议和负载均衡分别对应protocol 和 loadBalance,然后最终还是从容器中获取对应的实现。
<img src="_resources/0b1165a2e7ea4908bb9aaf0dbeea7629.png" alt="8b6ee8017d88ced6b088799024e9b729.png"></p>
<h3 id="初步的疑问">初步的疑问？</h3>
<p>Dubbo提供的扩展点是否会影响性能？ 每次都需要动态的查找对应的扩展点？ 对比普通的接口实现，Dubbo的扩展点优点是？它有哪些部分是必不可少的？ 当自己实现接口时，如何让Dubbo找到该实现，并实现调用？</p>
<h2 id="dubbo扩展点分类">Dubbo扩展点分类</h2>
<img src="_resources/a296e573daf14278be8ef262185051e1.png" alt="476a992ac8d47b0185a0959186f24a1e.png" width="610" height="564" class="jop-noMdConv"/>
<h3 id="指定名字扩展">指定名字扩展</h3>
<h4 id="实例">实例</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">LoadBalance loadBalance= ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(&quot;customLoadbalance&quot;);</pre><pre class="hljs"><code>LoadBalance loadBalance= ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(<span class="hljs-string">&quot;customLoadbalance&quot;</span>);</code></pre></div>
<h4 id="原理">原理</h4>
<ol>
<li>Dubbo首先从/META-INF/dubbo; /META-INF/internal这两个目录中，查找扩展点；</li>
<li>解析并加载扩展点；</li>
</ol>
<h4 id="获取extensionloader">获取ExtensionLoader</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@SuppressWarnings(&quot;unchecked&quot;)
public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {
    // type 为扩展点的抽象接口
    if (type == null) {
        throw new IllegalArgumentException(&quot;Extension type == null&quot;);
    }
    // 必须是接口
    if (!type.isInterface()) {
        throw new IllegalArgumentException(&quot;Extension type (&quot; + type + &quot;) is not an interface!&quot;);
    }
    // 接口必须带@SPI注解
    if (!withExtensionAnnotation(type)) {
        throw new IllegalArgumentException(&quot;Extension type (&quot; + type +
                &quot;) is not an extension, because it is NOT annotated with @&quot; + SPI.class.getSimpleName() + &quot;!&quot;);
    }
    // EXTENSION_LOADERS = ConcurrentHashMap容器，优先从容器中获取loader
    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    if (loader == null) {
        // 首次加载，将type作为参数，构造出一个ExtensionLoader
        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));
        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    }
    return loader;
}</pre><pre class="hljs"><code><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ExtensionLoader&lt;T&gt; <span class="hljs-title">getExtensionLoader</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>{
    <span class="hljs-comment">// type 为扩展点的抽象接口</span>
    <span class="hljs-keyword">if</span> (type == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Extension type == null&quot;</span>);
    }
    <span class="hljs-comment">// 必须是接口</span>
    <span class="hljs-keyword">if</span> (!type.isInterface()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Extension type (&quot;</span> + type + <span class="hljs-string">&quot;) is not an interface!&quot;</span>);
    }
    <span class="hljs-comment">// 接口必须带@SPI注解</span>
    <span class="hljs-keyword">if</span> (!withExtensionAnnotation(type)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Extension type (&quot;</span> + type +
                <span class="hljs-string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="hljs-string">&quot;!&quot;</span>);
    }
    <span class="hljs-comment">// EXTENSION_LOADERS = ConcurrentHashMap容器，优先从容器中获取loader</span>
    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 首次加载，将type作为参数，构造出一个ExtensionLoader</span>
        EXTENSION_LOADERS.putIfAbsent(type, <span class="hljs-keyword">new</span> ExtensionLoader&lt;T&gt;(type));
        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    }
    <span class="hljs-keyword">return</span> loader;
}</code></pre></div>
<p>getExtensionLoader获取指定type接口作为属性的ExtensionLoader对象。ExtensionLoader对象的构造方法有点特殊，内部包含objectFactory对象。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private ExtensionLoader(Class&lt;?&gt; type) {
    this.type = type;
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ExtensionLoader</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>{
    <span class="hljs-keyword">this</span>.type = type;
    objectFactory = (type == ExtensionFactory.class ? <span class="hljs-keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}</code></pre></div>
<p><code class="inline-code">objectFactory = ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</code>objectFactory是由getAdaptiveExtension()方法得到的,也就是说除了ExtensionFactory本身，其他的ExtensionLoader对应的objectFactory都是AdaptiveExtension。 小节: 最终得到的loader为new ExtensionLoader&lt;T&gt;(type);</p>
<blockquote>
<p>为什么每个扩展都需要一个ExtensionLoader? ExtensionLoader能否使用同一个？</p>
</blockquote>
<h4 id="获取指定名称扩展">获取指定名称扩展</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public T getExtension(String name) {
    return getExtension(name, true);
}

public T getExtension(String name, boolean wrap) {
    if (StringUtils.isEmpty(name)) {
        throw new IllegalArgumentException(&quot;Extension name == null&quot;);
    }
    if (&quot;true&quot;.equals(name)) {
        return getDefaultExtension();
    }
    // 创建一个Holder
    final Holder&lt;Object&gt; holder = getOrCreateHolder(name);
    Object instance = holder.get();
    if (instance == null) {
        synchronized (holder) {
            instance = holder.get();
            if (instance == null) {
                // 创造一个Extesion实例
                instance = createExtension(name, wrap);
                holder.set(instance);
            }
        }
    }
    return (T) instance;
}
首先对扩展点生成一个Holder，用于承载extension实例。createExtension的作用为创建一个Extionsion实例，并设置进Holder里面。</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getExtension</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">return</span> getExtension(name, <span class="hljs-keyword">true</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getExtension</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> wrap)</span> </span>{
    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Extension name == null&quot;</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(name)) {
        <span class="hljs-keyword">return</span> getDefaultExtension();
    }
    <span class="hljs-comment">// 创建一个Holder</span>
    <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);
    Object instance = holder.get();
    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span> (holder) {
            instance = holder.get();
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 创造一个Extesion实例</span>
                instance = createExtension(name, wrap);
                holder.set(instance);
            }
        }
    }
    <span class="hljs-keyword">return</span> (T) instance;
}
首先对扩展点生成一个Holder，用于承载extension实例。createExtension的作用为创建一个Extionsion实例，并设置进Holder里面。</code></pre></div>
<blockquote>
<p>Holder的作用是什么？ 防止缓存穿透？可以解决缓存穿透问题。但是这个地方并不是解决缓存穿透，如果是这样的话，instance == null就不需要做后面的createExtionsion了。</p>
</blockquote>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private T createExtension(String name, boolean wrap) {
    // 1. 从所有ExtionsionClasses找到对应的class文件。
    Class&lt;?&gt; clazz = getExtensionClasses().get(name);
    if (clazz == null) {
        throw findException(name);
    }
    try {
        T instance = (T) EXTENSION_INSTANCES.get(clazz);
        if (instance == null) {
            // 2. Extionsion实例化
            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
            instance = (T) EXTENSION_INSTANCES.get(clazz);
        }
        
        // 3. Extionsion依赖注入
        injectExtension(instance);

        if (wrap) {
            // 4. Extionstion 包装
            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = new ArrayList&lt;&gt;();
            if (cachedWrapperClasses != null) {
                wrapperClassesList.addAll(cachedWrapperClasses);
                wrapperClassesList.sort(WrapperComparator.COMPARATOR);
                Collections.reverse(wrapperClassesList);
            }
            if (CollectionUtils.isNotEmpty(wrapperClassesList)) {
                for (Class&lt;?&gt; wrapperClass : wrapperClassesList) {
                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);
                    if (wrapper == null
                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) {
                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                    }
                }
            }
        }

        // 5. 初始化扩展类
        initExtension(instance);
        return instance;
    } catch (Throwable t) {
        throw new IllegalStateException(&quot;Extension instance (name: &quot; + name + &quot;, class: &quot; +
                type + &quot;) couldn't be instantiated: &quot; + t.getMessage(), t);
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">createExtension</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> wrap)</span> </span>{
    <span class="hljs-comment">// 1. 从所有ExtionsionClasses找到对应的class文件。</span>
    Class&lt;?&gt; clazz = getExtensionClasses().get(name);
    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> findException(name);
    }
    <span class="hljs-keyword">try</span> {
        T instance = (T) EXTENSION_INSTANCES.get(clazz);
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 2. Extionsion实例化</span>
            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
            instance = (T) EXTENSION_INSTANCES.get(clazz);
        }
        
        <span class="hljs-comment">// 3. Extionsion依赖注入</span>
        injectExtension(instance);

        <span class="hljs-keyword">if</span> (wrap) {
            <span class="hljs-comment">// 4. Extionstion 包装</span>
            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-keyword">if</span> (cachedWrapperClasses != <span class="hljs-keyword">null</span>) {
                wrapperClassesList.addAll(cachedWrapperClasses);
                wrapperClassesList.sort(WrapperComparator.COMPARATOR);
                Collections.reverse(wrapperClassesList);
            }
            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) {
                <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) {
                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);
                    <span class="hljs-keyword">if</span> (wrapper == <span class="hljs-keyword">null</span>
                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) {
                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                    }
                }
            }
        }

        <span class="hljs-comment">// 5. 初始化扩展类</span>
        initExtension(instance);
        <span class="hljs-keyword">return</span> instance;
    } <span class="hljs-keyword">catch</span> (Throwable t) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Extension instance (name: &quot;</span> + name + <span class="hljs-string">&quot;, class: &quot;</span> +
                type + <span class="hljs-string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);
    }
}</code></pre></div>
<ol>
<li>从所有ExtionsionClasses找到对应的class文件。</li>
<li>Extionsion实例化</li>
<li>Extionsion依赖注入</li>
<li>Extionstion 包装</li>
<li>初始化扩展类</li>
</ol>
<h4 id="加载所有扩展点">加载所有扩展点</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {
    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
    if (classes == null) {
        synchronized (cachedClasses) {
            classes = cachedClasses.get();
            if (classes == null) {
                classes = loadExtensionClasses();
                cachedClasses.set(classes);
            }
        }
    }
    return classes;
}</pre><pre class="hljs"><code><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {
    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
    <span class="hljs-keyword">if</span> (classes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span> (cachedClasses) {
            classes = cachedClasses.get();
            <span class="hljs-keyword">if</span> (classes == <span class="hljs-keyword">null</span>) {
                classes = loadExtensionClasses();
                cachedClasses.set(classes);
            }
        }
    }
    <span class="hljs-keyword">return</span> classes;
}</code></pre></div>
<p>dubbo通过getExtensionClasses来查找扩展类，最终缓存在cachedClasses里面。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {
    cacheDefaultExtensionName();

    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;&gt;();

    // 遍历所有策略
    for (LoadingStrategy strategy : strategies) {
        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());
        // 兼容apache的域名
        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());
    }

    return extensionClasses;
}</pre><pre class="hljs"><code><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {
    cacheDefaultExtensionName();

    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-comment">// 遍历所有策略</span>
    <span class="hljs-keyword">for</span> (LoadingStrategy strategy : strategies) {
        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());
        <span class="hljs-comment">// 兼容apache的域名</span>
        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="hljs-string">&quot;org.apache&quot;</span>, <span class="hljs-string">&quot;com.alibaba&quot;</span>), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());
    }

    <span class="hljs-keyword">return</span> extensionClasses;
}</code></pre></div>
<p>根据strategy的使用(.directory())可以大致看出其每种策略应该对应的目录也不一样。也就是要从不同的目录下加载扩展类。</p>
<h5 id="各个策略strategy下加载扩展类">各个策略(Strategy)下加载扩展类</h5>
<p>策略的加载在其定义的地方：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private static volatile LoadingStrategy[] strategies = loadLoadingStrategies();</pre><pre class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> LoadingStrategy[] strategies = loadLoadingStrategies();</code></pre></div>
<p>具体的实现如下</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private static LoadingStrategy[] loadLoadingStrategies() {
    return stream(load(LoadingStrategy.class).spliterator(), false)
            .sorted()
            .toArray(LoadingStrategy[]::new);
}</pre><pre class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LoadingStrategy[] loadLoadingStrategies() {
    <span class="hljs-keyword">return</span> stream(load(LoadingStrategy.class).spliterator(), <span class="hljs-keyword">false</span>)
            .sorted()
            .toArray(LoadingStrategy[]::<span class="hljs-keyword">new</span>);
}</code></pre></div>
<p>通过JDK的ServiceLoaader机制，在META-INF/services目录下创建名为org.apache.dubbo.common.extension.LoadingStrategy的文件，配置如下;</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="properties" data-joplin-source-open="```properties&#10;" data-joplin-source-close="&#10;```">org.apache.dubbo.common.extension.DubboInternalLoadingStrategy
org.apache.dubbo.common.extension.DubboLoadingStrategy
org.apache.dubbo.common.extension.ServicesLoadingStrategy</pre><pre class="hljs"><code><span class="hljs-attr">org.apache.dubbo.common.extension.DubboInternalLoadingStrategy</span>
<span class="hljs-attr">org.apache.dubbo.common.extension.DubboLoadingStrategy</span>
<span class="hljs-attr">org.apache.dubbo.common.extension.ServicesLoadingStrategy</span></code></pre></div>
<img src="_resources/97a21c4b07c54d0ba40cfe4f3795ed24.png" alt="24a92dcc3e5af7fa934255b57a1ac059.png" width="836" height="193" class="jop-noMdConv"/>
<ul>
<li>DubboInternalLoadingStrategy : META-INF/dubbo/internal/</li>
<li>DubboLoadingStrategy : META-INF/dubbo/</li>
<li>ServicesLoadingStrategy : META-INF/services/ 通过以上三种策略，扫描三个目录下的扩展类。</li>
</ul>
<h5 id="extionsion注入内部扩展">Extionsion注入内部扩展</h5>
<p>createExtension调用Extension构造方法实例化，调用injectExtension注入内部持有的扩展。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private T injectExtension(T instance) {
    for (Method method : instance.getClass().getMethods()) {
            // 查找内部的setter方法
            if (!isSetter(method)) {
                continue;
            }
            // 如果方法上注有@DisableInject注解，则跳过
            if (method.getAnnotation(DisableInject.class) != null) {
                continue;
            }
            // 获取setter方法的第一个参数
            Class&lt;?&gt; pt = method.getParameterTypes()[0];
            if (ReflectUtils.isPrimitives(pt)) {
                continue;
            }

            try {
                // 根据方法，获取要注入的属性名称
                String property = getSetterProperty(method);
                // 获取扩展类实例
                Object object = objectFactory.getExtension(pt, property);
                if (object != null) {
                    method.invoke(instance, object);
                }
            } catch (Exception e) {
                logger.error(&quot;Failed to inject via method &quot; + method.getName()
                        + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);
            }

        }
    return instance;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">injectExtension</span><span class="hljs-params">(T instance)</span> </span>{
    <span class="hljs-keyword">for</span> (Method method : instance.getClass().getMethods()) {
            <span class="hljs-comment">// 查找内部的setter方法</span>
            <span class="hljs-keyword">if</span> (!isSetter(method)) {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">// 如果方法上注有@DisableInject注解，则跳过</span>
            <span class="hljs-keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">// 获取setter方法的第一个参数</span>
            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (ReflectUtils.isPrimitives(pt)) {
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 根据方法，获取要注入的属性名称</span>
                String property = getSetterProperty(method);
                <span class="hljs-comment">// 获取扩展类实例</span>
                Object object = objectFactory.getExtension(pt, property);
                <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span>) {
                    method.invoke(instance, object);
                }
            } <span class="hljs-keyword">catch</span> (Exception e) {
                logger.error(<span class="hljs-string">&quot;Failed to inject via method &quot;</span> + method.getName()
                        + <span class="hljs-string">&quot; of interface &quot;</span> + type.getName() + <span class="hljs-string">&quot;: &quot;</span> + e.getMessage(), e);
            }

        }
    <span class="hljs-keyword">return</span> instance;
}</code></pre></div>
<p>”获取ExtensionLoader“小节中说道，除了ExtensionFactory的objectFactory=null, 其他的扩展点对应的objectFactory对象都是通过getAdaptiveExtension()而来的。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private ExtensionLoader(Class&lt;?&gt; type) {
    this.type = type;
    objectFactory = null;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ExtensionLoader</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>{
    <span class="hljs-keyword">this</span>.type = type;
    objectFactory = <span class="hljs-keyword">null</span>;
}</code></pre></div>
<p>即通过以上对象构建，对应的getAdaptiveExtension()而来。</p>
<h5 id="extensionfactory是什么">ExtensionFactory是什么？</h5>
<p>ExtensionFactory主要用于获取Extension实例的。但是它本身也是可以作为扩展点的，如下：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@SPI
public interface ExtensionFactory {
    &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name);
}</pre><pre class="hljs"><code><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExtensionFactory</span> </span>{
    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getExtension</span><span class="hljs-params">(Class&lt;T&gt; type, String name)</span></span>;
}</code></pre></div>
<p><img src="_resources/eb7de9dd13784b56869cb07cee212915.png" alt="b1a18252ae94d03ad46ab54089f0ecef.png">
可见其有三种实现，分别是从Spring容器中获取、其他两个本质上，还是获取AdaptiveExtension实例。
AdaptiveExtension最终也是通过： ExtensionLoader.getExtensionLoader(type).getExtension()来实现的。最终注入进去的是一个自适应的扩展类实例。</p>
<ul>
<li>SpringExtentionFactory: 根据名称以及类型从Spring容器中获取bean，如果该bean类型是SPI, 则需要从SpiExtentionFactory中获取；</li>
<li>SpiExtentionFactory: 从指定ExtensionLoader中获取自适应的扩展点实现，无非就是指定Dubbo扫描路径下的AdaptiveExtension实例。</li>
<li>AdaptiveExtensionFactory: 分别从所有的ExtensionFactory中获取
dubbo在执行getExtensionClasses完成ExtensionClass扫描时，如果扫描的到带有@Adaptive注解的类，</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,
                           boolean overridden) throws NoSuchMethodException {
        ...
        if (clazz.isAnnotationPresent(Adaptive.class)) {
            cacheAdaptiveClass(clazz, overridden);
        } else if (isWrapperClass(clazz)) {
        ....
        }
    }
</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadClass</span><span class="hljs-params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,
                           <span class="hljs-keyword">boolean</span> overridden)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>{
        ...
        <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) {
            cacheAdaptiveClass(clazz, overridden);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWrapperClass(clazz)) {
        ....
        }
    }
</code></pre></div>
<p>则将其缓存到ExtensionLoader中:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private void cacheAdaptiveClass(Class&lt;?&gt; clazz, boolean overridden) {
    if (cachedAdaptiveClass == null || overridden) {
        cachedAdaptiveClass = clazz;
    } else if (!cachedAdaptiveClass.equals(clazz)) {
        throw new IllegalStateException(&quot;More than 1 adaptive class found: &quot;
                + cachedAdaptiveClass.getName()
                + &quot;, &quot; + clazz.getName());
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheAdaptiveClass</span><span class="hljs-params">(Class&lt;?&gt; clazz, <span class="hljs-keyword">boolean</span> overridden)</span> </span>{
    <span class="hljs-keyword">if</span> (cachedAdaptiveClass == <span class="hljs-keyword">null</span> || overridden) {
        cachedAdaptiveClass = clazz;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;More than 1 adaptive class found: &quot;</span>
                + cachedAdaptiveClass.getName()
                + <span class="hljs-string">&quot;, &quot;</span> + clazz.getName());
    }
}</code></pre></div>
<p>cachedAdaptiveClass属于ExtensionLoader的一个内部属性:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private volatile Class&lt;?&gt; cachedAdaptiveClass = null;</pre><pre class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="hljs-keyword">null</span>;</code></pre></div>
<p>那Dubbo中是否有包含@Adaptive注解的类呢？</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@Adaptive
public class AdaptiveExtensionFactory implements ExtensionFactory {
    private final List&lt;ExtensionFactory&gt; factories;

    public AdaptiveExtensionFactory() {
        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
        List&lt;ExtensionFactory&gt; list = new ArrayList&lt;ExtensionFactory&gt;();
        for (String name : loader.getSupportedExtensions()) {
            list.add(loader.getExtension(name));
        }
        factories = Collections.unmodifiableList(list);
    }

    @Override
    public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) {
        for (ExtensionFactory factory : factories) {
            T extension = factory.getExtension(type, name);
            if (extension != null) {
                return extension;
            }
        }
        return null;
    }

}</pre><pre class="hljs"><code><span class="hljs-meta">@Adaptive</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdaptiveExtensionFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExtensionFactory</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ExtensionFactory&gt; factories;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdaptiveExtensionFactory</span><span class="hljs-params">()</span> </span>{
        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
        List&lt;ExtensionFactory&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();
        <span class="hljs-keyword">for</span> (String name : loader.getSupportedExtensions()) {
            list.add(loader.getExtension(name));
        }
        factories = Collections.unmodifiableList(list);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getExtension</span><span class="hljs-params">(Class&lt;T&gt; type, String name)</span> </span>{
        <span class="hljs-keyword">for</span> (ExtensionFactory factory : factories) {
            T extension = factory.getExtension(type, name);
            <span class="hljs-keyword">if</span> (extension != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> extension;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

}</code></pre></div>
<p>AdaptiveExtensionFactory作为ExtensionFatory的适配类，用于适配SPI查找机制和Spring容器查找机制。那么在其他ExtensionLoader中，如果要构造ObjectFactory:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private ExtensionLoader(Class&lt;?&gt; type) {
    this.type = type;
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ExtensionLoader</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>{
    <span class="hljs-keyword">this</span>.type = type;
    objectFactory = (type == ExtensionFactory.class ? <span class="hljs-keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}</code></pre></div>
<p>其对应的objectFactory应该就是AdaptiveExtensionFactory对象了。</p>
<h5 id="extension-包装">Extension 包装</h5>
<p>在dubbo中，如果在加载SPI扩展点时，一个被扫描到的类对应的构造函数带有SPI扩展抽象接口，则该类被定为包装类：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">private boolean isWrapperClass(Class&lt;?&gt; clazz) {
    try {
        clazz.getConstructor(type);
        return true;
    } catch (NoSuchMethodException e) {
        return false;
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWrapperClass</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>{
    <span class="hljs-keyword">try</span> {
        clazz.getConstructor(type);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    } <span class="hljs-keyword">catch</span> (NoSuchMethodException e) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}</code></pre></div>
<p>例如: ProtocolListenerWrapper, 虽然他是Protocol的实现，但他是被作为一个包装类存在。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public class ProtocolListenerWrapper implements Protocol {
    private final Protocol protocol;
    public ProtocolListenerWrapper(Protocol protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException(&quot;protocol == null&quot;);
        }
        this.protocol = protocol;
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtocolListenerWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Protocol</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Protocol protocol;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProtocolListenerWrapper</span><span class="hljs-params">(Protocol protocol)</span> </span>{
        <span class="hljs-keyword">if</span> (protocol == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;protocol == null&quot;</span>);
        }
        <span class="hljs-keyword">this</span>.protocol = protocol;
    }
}</code></pre></div>
<h3 id="自适应扩展">自适应扩展</h3>
<p>@Adaptive既可以声明在方法上，也可以声明在类上；</p>
<ul>
<li>方法: 动态生成代理类，并实现对应的方法。</li>
<li>类: 该类被指定成一个自适应的默认的类。
根据@Adaptive解释，value()决定了被注入的扩展点是需要<strong>根据URL里面的参数</strong>、或者是<strong>value()方法所返回的值</strong>来决定的。如果从URL中获取不到对应的参数值，则只好使用@SPI注解上声明的默认扩展点，如果仍然未声明，只好跑出IllegalStateException。@Aadaptive({&quot;key1&quot;, &quot;key2&quot;}), 代表先从URL中获取Key1值，如果获取不到，再去获取Key2值，如果获取到了， 就用其值作为扩展点的名字，去扩展点缓存中进行查询。</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Adaptive {
    String[] value() default {};
}</pre><pre class="hljs"><code><span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ElementType.TYPE, ElementType.METHOD})</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Adaptive {
    String[] value() <span class="hljs-keyword">default</span> {};
}</code></pre></div>
<h4 id="loadbalance自适应扩展-方法注解实现">LoadBalance自适应扩展-方法注解实现</h4>
<p>例如LoadBalance的自适应扩展定义如下 ：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@SPI(RandomLoadBalance.NAME)
public interface LoadBalance {

    /**
     * select one invoker in list.
     *
     * @param invokers   invokers.
     * @param url        refer url
     * @param invocation invocation.
     * @return selected invoker.
     */
    @Adaptive(&quot;loadbalance&quot;)
    &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;

}</pre><pre class="hljs"><code><span class="hljs-meta">@SPI(RandomLoadBalance.NAME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalance</span> </span>{

    <span class="hljs-comment">/**
     * select one invoker in list.
     *
     * <span class="hljs-doctag">@param</span> invokers   invokers.
     * <span class="hljs-doctag">@param</span> url        refer url
     * <span class="hljs-doctag">@param</span> invocation invocation.
     * <span class="hljs-doctag">@return</span> selected invoker.
     */</span>
    <span class="hljs-meta">@Adaptive(&quot;loadbalance&quot;)</span>
    &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException</span>;

}</code></pre></div>
<p>那么其自适应扩展应该动态生成代理类，并实现select方法，我们通过以下Test：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">LoadBalance loadBalance= ExtensionLoader.getExtensionLoader(LoadBalance.class).getAdaptiveExtension();</pre><pre class="hljs"><code>LoadBalance loadBalance= ExtensionLoader.getExtensionLoader(LoadBalance.class).getAdaptiveExtension();</code></pre></div>
<p>获取器最终生成的的动态代理类如下:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">import org.apache.dubbo.common.URL;
import org.apache.dubbo.common.extension.ExtensionLoader;
import org.apache.dubbo.rpc.Invocation;
import org.apache.dubbo.rpc.Invoker;
import org.apache.dubbo.rpc.RpcException;

import java.util.List;

public class LoadBalance$Adaptive implements LoadBalance {
    @Override
    public Invoker select(List arg0, URL arg1, Invocation arg2) throws RpcException {
        // URL校验
        if (arg1 == null) {
            throw new IllegalArgumentException(&quot;url == null&quot;);
        }
        URL url = arg1;
        // Invocation校验
        if (arg2 == null) {
            throw new IllegalArgumentException(&quot;invocation == null&quot;);
        }
        // 取出Invocation的方法名称
        String methodName = arg2.getMethodName();
        // 取出URL中对应方法的值，如果没有loadbalance，就取出random的值
        String extName = url.getMethodParameter(methodName, &quot;loadbalance&quot;, &quot;random&quot;);
        if (extName == null) {
            throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.cluster.LoadBalance) name from url (&quot; + url.toString() + &quot;) use keys([loadbalance])&quot;);
        }
        // 取出对应的扩展点名称的扩展实现
        LoadBalance extension = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(extName);
        return extension.select(arg0, arg1, arg2);
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;
<span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invocation;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invoker;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.RpcException;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalance</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Invoker <span class="hljs-title">select</span><span class="hljs-params">(List arg0, URL arg1, Invocation arg2)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
        <span class="hljs-comment">// URL校验</span>
        <span class="hljs-keyword">if</span> (arg1 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;url == null&quot;</span>);
        }
        URL url = arg1;
        <span class="hljs-comment">// Invocation校验</span>
        <span class="hljs-keyword">if</span> (arg2 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;invocation == null&quot;</span>);
        }
        <span class="hljs-comment">// 取出Invocation的方法名称</span>
        String methodName = arg2.getMethodName();
        <span class="hljs-comment">// 取出URL中对应方法的值，如果没有loadbalance，就取出random的值</span>
        String extName = url.getMethodParameter(methodName, <span class="hljs-string">&quot;loadbalance&quot;</span>, <span class="hljs-string">&quot;random&quot;</span>);
        <span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Failed to get extension (org.apache.dubbo.rpc.cluster.LoadBalance) name from url (&quot;</span> + url.toString() + <span class="hljs-string">&quot;) use keys([loadbalance])&quot;</span>);
        }
        <span class="hljs-comment">// 取出对应的扩展点名称的扩展实现</span>
        LoadBalance extension = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(extName);
        <span class="hljs-keyword">return</span> extension.select(arg0, arg1, arg2);
    }
}</code></pre></div>
<p><code class="inline-code">url.getMethodParameter(methodName, &quot;loadbalance&quot;, &quot;random&quot;);</code>中的&quot;loadbalance&quot;是@Adaptive(&quot;loadbalance&quot;)中定义的首选Key1, 而&quot;random&quot;对应的是@SPI(RandomLoadBalance.NAME)中定义的备选Key2.</p>
<h4 id="protocol自适应扩展-方法注解实现">Protocol自适应扩展-方法注解实现</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">package org.apache.dubbo.rpc;

import org.apache.dubbo.common.URL;
import org.apache.dubbo.common.extension.ExtensionLoader;

import java.util.List;

public class Protocol$Adaptive implements Protocol {
    @Override
    public void destroy() {
        throw new UnsupportedOperationException(&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
    }

    @Override
    public int getDefaultPort() {
        throw new UnsupportedOperationException(&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
    }

    @Override
    public Exporter export(Invoker arg0) throws org.apache.dubbo.rpc.RpcException {
        if (arg0 == null) {
            throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;);
        }
        if (arg0.getUrl() == null) {
            throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;);
        }
        // 获取URL
        URL url = arg0.getUrl();
        // 从URL中获取协议
        String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
        if (extName == null) {
            throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
        }
        // 根据扩展点名称获取指定扩展点
        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);
        return extension.export(arg0);
    }

    @Override
    public Invoker refer(Class arg0, URL arg1) throws RpcException {
        if (arg1 == null) {
            throw new IllegalArgumentException(&quot;url == null&quot;);
        }
        URL url = arg1;
        String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
        if (extName == null) {
            throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
        }
        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);
        return extension.refer(arg0, arg1);
    }

    @Override
    public List getServers() {
        throw new UnsupportedOperationException(&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">package</span> org.apache.dubbo.rpc;

<span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;
<span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Protocol</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultPort</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Exporter <span class="hljs-title">export</span><span class="hljs-params">(Invoker arg0)</span> <span class="hljs-keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>{
        <span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);
        }
        <span class="hljs-keyword">if</span> (arg0.getUrl() == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);
        }
        <span class="hljs-comment">// 获取URL</span>
        URL url = arg0.getUrl();
        <span class="hljs-comment">// 从URL中获取协议</span>
        String extName = (url.getProtocol() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;dubbo&quot;</span> : url.getProtocol());
        <span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="hljs-string">&quot;) use keys([protocol])&quot;</span>);
        }
        <span class="hljs-comment">// 根据扩展点名称获取指定扩展点</span>
        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);
        <span class="hljs-keyword">return</span> extension.export(arg0);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Invoker <span class="hljs-title">refer</span><span class="hljs-params">(Class arg0, URL arg1)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
        <span class="hljs-keyword">if</span> (arg1 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;url == null&quot;</span>);
        }
        URL url = arg1;
        String extName = (url.getProtocol() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;dubbo&quot;</span> : url.getProtocol());
        <span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="hljs-string">&quot;) use keys([protocol])&quot;</span>);
        }
        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);
        <span class="hljs-keyword">return</span> extension.refer(arg0, arg1);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getServers</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);
    }
}</code></pre></div>
<h4 id="adaptivecompiler自适应扩展-类注解实现">AdaptiveCompiler自适应扩展-类注解实现</h4>
<p>如AdaptiveExtensionFactor的结构类似，Compiler的@Adaptive注解也标注在类上。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@Adaptive
public class AdaptiveCompiler implements Compiler {

    private static volatile String DEFAULT_COMPILER;

    public static void setDefaultCompiler(String compiler) {
        DEFAULT_COMPILER = compiler;
    }

    @Override
    public Class&lt;?&gt; compile(String code, ClassLoader classLoader) {
        Compiler compiler;
        // 获取扩展点加载类
        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class);
        String name = DEFAULT_COMPILER; // copy reference
        if (name != null &amp;&amp; name.length() &gt; 0) {
            // 如果有指定默认的扩展点实现，则直接使用
            compiler = loader.getExtension(name);
        } else {
            // 如果未指定，则调用DefaultExtension
            compiler = loader.getDefaultExtension();
        }
        return compiler.compile(code, classLoader);
    }

}</pre><pre class="hljs"><code><span class="hljs-meta">@Adaptive</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdaptiveCompiler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Compiler</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> String DEFAULT_COMPILER;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefaultCompiler</span><span class="hljs-params">(String compiler)</span> </span>{
        DEFAULT_COMPILER = compiler;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) {
        Compiler compiler;
        <span class="hljs-comment">// 获取扩展点加载类</span>
        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class);
        String name = DEFAULT_COMPILER; <span class="hljs-comment">// copy reference</span>
        <span class="hljs-keyword">if</span> (name != <span class="hljs-keyword">null</span> &amp;&amp; name.length() &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 如果有指定默认的扩展点实现，则直接使用</span>
            compiler = loader.getExtension(name);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果未指定，则调用DefaultExtension</span>
            compiler = loader.getDefaultExtension();
        }
        <span class="hljs-keyword">return</span> compiler.compile(code, classLoader);
    }

}</code></pre></div>
<p>自适应扩展点就是要根据某种条件，灵活的选择相应的扩展点实现。AdaptiveExtensionFactory的灵活性在于它可以取自灵活的</p>
<h3 id="扩展点激活activate">扩展点激活@Activate</h3>
<h4 id="原理-2">原理</h4>
<p>以Filter的扩展点为例，FIlter扩展的接口为：org.apache.dubbo.rpc.Filter
该接口有很多的实现:
例如: org.apache.dubbo.cache.filter.CacheFilter、org.apache.dubbo.rpc.filter.ActiveLimitFilter、org.apache.dubbo.rpc.filter.EchoFilter
我们通过以下代码来看dubbo是如何激活扩展点的：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">URL url = new URL(&quot;&quot;, &quot;&quot;,0);
List&lt;Filter&gt; cache = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(url, &quot;cache&quot;);
cache.forEach((t) -&gt; {
    System.out.println(t);
});</pre><pre class="hljs"><code>URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>);
List&lt;Filter&gt; cache = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(url, <span class="hljs-string">&quot;cache&quot;</span>);
cache.forEach((t) -&gt; {
    System.out.println(t);
});</code></pre></div>
<p>结果打印了10条数据；</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">org.apache.dubbo.rpc.filter.EchoFilter@4ec4f3a0
org.apache.dubbo.rpc.filter.ClassLoaderFilter@223191a6
org.apache.dubbo.rpc.filter.GenericFilter@49139829
org.apache.dubbo.rpc.filter.ConsumerContextFilter@9597028
org.apache.dubbo.rpc.filter.ContextFilter@6069db50
org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter@4efbca5a
org.apache.dubbo.rpc.protocol.dubbo.filter.TraceFilter@1b7cc17c
org.apache.dubbo.rpc.filter.TimeoutFilter@59662a0b
org.apache.dubbo.monitor.support.MonitorFilter@77fbd92c
org.apache.dubbo.rpc.filter.ExceptionFilter@67c27493</pre><pre class="hljs"><code>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.EchoFilter@<span class="hljs-number">4</span>ec4f3a0
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.ClassLoaderFilter@<span class="hljs-number">223191</span>a6
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.GenericFilter@<span class="hljs-number">49139829</span>
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.ConsumerContextFilter@<span class="hljs-number">9597028</span>
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.ContextFilter@<span class="hljs-number">6069</span>db50
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.filter</span>.FutureFilter@<span class="hljs-number">4</span>efbca5a
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.filter</span>.TraceFilter@<span class="hljs-number">1</span>b7cc17c
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.TimeoutFilter@<span class="hljs-number">59662</span>a0b
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.monitor</span><span class="hljs-selector-class">.support</span>.MonitorFilter@<span class="hljs-number">77</span>fbd92c
org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.filter</span>.ExceptionFilter@<span class="hljs-number">67</span>c27493</code></pre></div>
<p>但是FIlter的实现远远没有这么多，并且，如果都要加载的话，也浪费性能，那怎么办呢？我们发现打印的这部分Filter看起来像是默认的。
观察EchoFilter，和ClassLoaderFilter，我们发现其注解定义如下:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@Activate(group = CommonConstants.PROVIDER, order = -110000)
public class EchoFilter implements Filter {}

@Activate(group = CommonConstants.PROVIDER, order = -30000)
public class ClassLoaderFilter implements Filter {}</pre><pre class="hljs"><code><span class="hljs-meta">@Activate(group = CommonConstants.PROVIDER, order = -110000)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>{}

<span class="hljs-meta">@Activate(group = CommonConstants.PROVIDER, order = -30000)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>{}</code></pre></div>
<p>我们再看@Activate注解的定义:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Activate {
    String[] group() default {};
     /**
     * Activate the current extension when the specified keys appear in the URL's parameters.
     * &lt;p&gt;
     * For example, given &lt;code&gt;@Activate(&quot;cache, validation&quot;)&lt;/code&gt;, the current extension will be return only when
     * there's either &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;validation&lt;/code&gt; key appeared in the URL's parameters.
     * &lt;/p&gt;
     *
     * @return URL parameter keys
     * @see ExtensionLoader#getActivateExtension(URL, String)
     * @see ExtensionLoader#getActivateExtension(URL, String, String)
     */
    String[] value() default {};
    int order() default 0;
}</pre><pre class="hljs"><code><span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ElementType.TYPE, ElementType.METHOD})</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Activate {
    String[] group() <span class="hljs-keyword">default</span> {};
     <span class="hljs-comment">/**
     * Activate the current extension when the specified keys appear in the URL&#x27;s parameters.
     * &lt;p&gt;
     * For example, given &lt;code&gt;<span class="hljs-doctag">@Activate</span>(&quot;cache, validation&quot;)&lt;/code&gt;, the current extension will be return only when
     * there&#x27;s either &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;validation&lt;/code&gt; key appeared in the URL&#x27;s parameters.
     * &lt;/p&gt;
     *
     * <span class="hljs-doctag">@return</span> URL parameter keys
     * <span class="hljs-doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String)
     * <span class="hljs-doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)
     */</span>
    String[] value() <span class="hljs-keyword">default</span> {};
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;
}</code></pre></div>
<p>该注解的value值其实是用于激活扩展点的，例如: @Activate(&quot;cache, validation&quot;), 表示当URL中包含这两个任意一个参数，才能被激活，否则不能被激活。</p>
<blockquote>
<p>@Activate 上的group()代表是用于服务端还是用于客户端，例如group = {CONSUMER, PROVIDER}，代表两端都可以使用。如果没有指定的话，相当于不设限。</p>
</blockquote>
<p>经过分析之后，我们将代码改成这样 :</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">URL url = new URL(&quot;&quot;, &quot;&quot;,0);
url = url.addParameter(&quot;param&quot;, &quot;cache&quot;);
List&lt;Filter&gt; cache = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(url,&quot;param&quot;);
cache.forEach((t) -&gt; {
    System.out.println(t);
});</pre><pre class="hljs"><code>URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>);
url = url.addParameter(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;cache&quot;</span>);
List&lt;Filter&gt; cache = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(url,<span class="hljs-string">&quot;param&quot;</span>);
cache.forEach((t) -&gt; {
    System.out.println(t);
});</code></pre></div>
<p>最终得到了CacheFilter。</p>
<h4 id="源码分析">源码分析</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public List&lt;T&gt; getActivateExtension(URL url, String key) {
    return getActivateExtension(url, key, null);
}
public List&lt;T&gt; getActivateExtension(URL url, String key, String group) {
    String value = url.getParameter(key);
    return getActivateExtension(url, StringUtils.isEmpty(value) ? null : COMMA_SPLIT_PATTERN.split(value), group);
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getActivateExtension</span><span class="hljs-params">(URL url, String key)</span> </span>{
    <span class="hljs-keyword">return</span> getActivateExtension(url, key, <span class="hljs-keyword">null</span>);
}
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getActivateExtension</span><span class="hljs-params">(URL url, String key, String group)</span> </span>{
    String value = url.getParameter(key);
    <span class="hljs-keyword">return</span> getActivateExtension(url, StringUtils.isEmpty(value) ? <span class="hljs-keyword">null</span> : COMMA_SPLIT_PATTERN.split(value), group);
}</code></pre></div>
<p>默认给group参数传null, 相当于不对group进行设限制；</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) {
    List&lt;T&gt; activateExtensions = new ArrayList&lt;&gt;();
    List&lt;String&gt; names = values == null ? new ArrayList&lt;&gt;(0) : asList(values);
    if (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) {
        getExtensionClasses();
        for (Map.Entry&lt;String, Object&gt; entry : cachedActivates.entrySet()) {
            // 遍历指定类的所有激活性扩展点
            // 获取名称
            String name = entry.getKey();
            // 获取指定参数值
            Object activate = entry.getValue();

            String[] activateGroup, activateValue;

            if (activate instanceof Activate) {
                activateGroup = ((Activate) activate).group();
                activateValue = ((Activate) activate).value();
            } else if (activate instanceof com.alibaba.dubbo.common.extension.Activate) {
                activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();
                activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();
            } else {
                continue;
            }
            if (isMatchGroup(group, activateGroup) // 该扩展点实现对应的group是否符合要求
                    &amp;&amp; !names.contains(name) // 确保不做重复add
                    &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)
                    // 如果@Adative注解无value值，则说明对Extension不做URL参数限制，相当于默认的已被激活的扩展实现
                    // 如果@Adative注解有value值，则说明对Extension做URL参数限制,要从url中提取参数，要提取出包含value值中的其中一个，否则不可以注入，例如: CacheFilter, 其@Adative注解值为&quot;cache&quot;, 说明其要求URL中必须要包含&quot;cache&quot;参数。
                    &amp;&amp; isActive(activateValue, url)) {
                activateExtensions.add(getExtension(name));
            }
        }
        activateExtensions.sort(ActivateComparator.COMPARATOR);
    }
    // 将URL中指定名字的扩展点缓存到loadedExtensions
    List&lt;T&gt; loadedExtensions = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; names.size(); i++) {
        String name = names.get(i);
        if (!name.startsWith(REMOVE_VALUE_PREFIX)
                &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)) {
            if (DEFAULT_KEY.equals(name)) {
                if (!loadedExtensions.isEmpty()) {
                    activateExtensions.addAll(0, loadedExtensions);
                    loadedExtensions.clear();
                }
            } else {
                loadedExtensions.add(getExtension(name));
            }
        }
    }
    if (!loadedExtensions.isEmpty()) {
        activateExtensions.addAll(loadedExtensions);
    }
    // 返回所有的扩展点实现
    return activateExtensions;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getActivateExtension</span><span class="hljs-params">(URL url, String[] values, String group)</span> </span>{
    List&lt;T&gt; activateExtensions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; names = values == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">0</span>) : asList(values);
    <span class="hljs-keyword">if</span> (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) {
        getExtensionClasses();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : cachedActivates.entrySet()) {
            <span class="hljs-comment">// 遍历指定类的所有激活性扩展点</span>
            <span class="hljs-comment">// 获取名称</span>
            String name = entry.getKey();
            <span class="hljs-comment">// 获取指定参数值</span>
            Object activate = entry.getValue();

            String[] activateGroup, activateValue;

            <span class="hljs-keyword">if</span> (activate <span class="hljs-keyword">instanceof</span> Activate) {
                activateGroup = ((Activate) activate).group();
                activateValue = ((Activate) activate).value();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (activate <span class="hljs-keyword">instanceof</span> com.alibaba.dubbo.common.extension.Activate) {
                activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();
                activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (isMatchGroup(group, activateGroup) <span class="hljs-comment">// 该扩展点实现对应的group是否符合要求</span>
                    &amp;&amp; !names.contains(name) <span class="hljs-comment">// 确保不做重复add</span>
                    &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)
                    <span class="hljs-comment">// 如果@Adative注解无value值，则说明对Extension不做URL参数限制，相当于默认的已被激活的扩展实现</span>
                    <span class="hljs-comment">// 如果@Adative注解有value值，则说明对Extension做URL参数限制,要从url中提取参数，要提取出包含value值中的其中一个，否则不可以注入，例如: CacheFilter, 其@Adative注解值为&quot;cache&quot;, 说明其要求URL中必须要包含&quot;cache&quot;参数。</span>
                    &amp;&amp; isActive(activateValue, url)) {
                activateExtensions.add(getExtension(name));
            }
        }
        activateExtensions.sort(ActivateComparator.COMPARATOR);
    }
    <span class="hljs-comment">// 将URL中指定名字的扩展点缓存到loadedExtensions</span>
    List&lt;T&gt; loadedExtensions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; names.size(); i++) {
        String name = names.get(i);
        <span class="hljs-keyword">if</span> (!name.startsWith(REMOVE_VALUE_PREFIX)
                &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)) {
            <span class="hljs-keyword">if</span> (DEFAULT_KEY.equals(name)) {
                <span class="hljs-keyword">if</span> (!loadedExtensions.isEmpty()) {
                    activateExtensions.addAll(<span class="hljs-number">0</span>, loadedExtensions);
                    loadedExtensions.clear();
                }
            } <span class="hljs-keyword">else</span> {
                loadedExtensions.add(getExtension(name));
            }
        }
    }
    <span class="hljs-keyword">if</span> (!loadedExtensions.isEmpty()) {
        activateExtensions.addAll(loadedExtensions);
    }
    <span class="hljs-comment">// 返回所有的扩展点实现</span>
    <span class="hljs-keyword">return</span> activateExtensions;
}</code></pre></div>
<h2 id="dubbo扩展点实例">Dubbo扩展点实例</h2>
<p>以下是负载均衡的随机负载扩展点实现 :</p>
<ol>
<li>具体的实现如下</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public class RandomLoadBalance extends AbstractLoadBalance {

    public static final String NAME = &quot;random&quot;;
    
    @Override
    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {
        // Number of invokers
        int length = invokers.size();
        // Every invoker has the same weight?
        boolean sameWeight = true;
        // the weight of every invokers
        int[] weights = new int[length];
        // the first invoker's weight
        int firstWeight = getWeight(invokers.get(0), invocation);
        weights[0] = firstWeight;
        
        
        //1. 计算所有总权重值；
        //2. 判断是否权重值一致；	
        int totalWeight = firstWeight;
        for (int i = 1; i &lt; length; i++) {
            int weight = getWeight(invokers.get(i), invocation);
            // save for later use
            weights[i] = weight;
            // Sum
            totalWeight += weight;
            if (sameWeight &amp;&amp; weight != firstWeight) {
                sameWeight = false;
            }
        }
        
        //权重值不一致，则根据权重值选取
        // 假设权重值分别为： 30%, 35%, 40%, 5%
        // 权重总值为 :110%, 随机选择该范围内的一个权重值: 75
        // 依次从权重值中对该值做减法，直到被选取的随机权重值被减到负数，就是哪个被选中了。
        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {
            // If (not every invoker has the same weight &amp; at least one 
            // invoker's weight&gt;0), select randomly based on totalWeight.
            int offset = ThreadLocalRandom.current().nextInt(totalWeight);
            // Return a invoker based on the random value.
            for (int i = 0; i &lt; length; i++) {
                offset -= weights[i];
                if (offset &lt; 0) {
                    return invokers.get(i);
                }
            }
        }
        
        //权重值一致，则随机选取一个
        return invokers.get(ThreadLocalRandom.current().nextInt(length));
    }
</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">&quot;random&quot;</span>;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        <span class="hljs-comment">// Number of invokers</span>
        <span class="hljs-keyword">int</span> length = invokers.size();
        <span class="hljs-comment">// Every invoker has the same weight?</span>
        <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">// the weight of every invokers</span>
        <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];
        <span class="hljs-comment">// the first invoker&#x27;s weight</span>
        <span class="hljs-keyword">int</span> firstWeight = getWeight(invokers.get(<span class="hljs-number">0</span>), invocation);
        weights[<span class="hljs-number">0</span>] = firstWeight;
        
        
        <span class="hljs-comment">//1. 计算所有总权重值；</span>
        <span class="hljs-comment">//2. 判断是否权重值一致；	</span>
        <span class="hljs-keyword">int</span> totalWeight = firstWeight;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) {
            <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);
            <span class="hljs-comment">// save for later use</span>
            weights[i] = weight;
            <span class="hljs-comment">// Sum</span>
            totalWeight += weight;
            <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {
                sameWeight = <span class="hljs-keyword">false</span>;
            }
        }
        
        <span class="hljs-comment">//权重值不一致，则根据权重值选取</span>
        <span class="hljs-comment">// 假设权重值分别为： 30%, 35%, 40%, 5%</span>
        <span class="hljs-comment">// 权重总值为 :110%, 随机选择该范围内的一个权重值: 75</span>
        <span class="hljs-comment">// 依次从权重值中对该值做减法，直到被选取的随机权重值被减到负数，就是哪个被选中了。</span>
        <span class="hljs-keyword">if</span> (totalWeight &gt; <span class="hljs-number">0</span> &amp;&amp; !sameWeight) {
            <span class="hljs-comment">// If (not every invoker has the same weight &amp; at least one </span>
            <span class="hljs-comment">// invoker&#x27;s weight&gt;0), select randomly based on totalWeight.</span>
            <span class="hljs-keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);
            <span class="hljs-comment">// Return a invoker based on the random value.</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                offset -= weights[i];
                <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> invokers.get(i);
                }
            }
        }
        
        <span class="hljs-comment">//权重值一致，则随机选取一个</span>
        <span class="hljs-keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));
    }
</code></pre></div>
<ol start="2">
<li>添加配置</li>
</ol>
<img src="_resources/bb771c7476f64392a41d1f11727681ee.png" alt="87b5b06e2862a3e8a2f66ea80d1bd3a9.png" width="475" height="248" class="jop-noMdConv"/>
<p>配置内容如下:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="properties" data-joplin-source-open="```properties&#10;" data-joplin-source-close="&#10;```">random=org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance
roundrobin=org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance
leastactive=org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance
consistenthash=org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance
shortestresponse=org.apache.dubbo.rpc.cluster.loadbalance.ShortestResponseLoadBalance</pre><pre class="hljs"><code><span class="hljs-attr">random</span>=<span class="hljs-string">org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</span>
<span class="hljs-attr">roundrobin</span>=<span class="hljs-string">org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</span>
<span class="hljs-attr">leastactive</span>=<span class="hljs-string">org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</span>
<span class="hljs-attr">consistenthash</span>=<span class="hljs-string">org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</span>
<span class="hljs-attr">shortestresponse</span>=<span class="hljs-string">org.apache.dubbo.rpc.cluster.loadbalance.ShortestResponseLoadBalance</span></code></pre></div>
<h2 id="如何自己去实现一个扩展点">如何自己去实现一个扩展点？</h2>
<ol>
<li>自定义实现</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">import org.apache.dubbo.common.URL;
import org.apache.dubbo.rpc.Invocation;
import org.apache.dubbo.rpc.Invoker;
import org.apache.dubbo.rpc.RpcException;
import org.apache.dubbo.rpc.cluster.LoadBalance;

import java.util.List;

public class CustomLoadbalance implements LoadBalance {
    @Override
    public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException {
        return ...;
    }
}
</pre><pre class="hljs"><code><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invocation;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invoker;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.RpcException;
<span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.LoadBalance;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomLoadbalance</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
        <span class="hljs-keyword">return</span> ...;
    }
}
</code></pre></div>
<ol start="2">
<li>添加配置文件</li>
</ol>
<img src="_resources/f0fd100b230540b09ddb9dc41ca7e730.png" alt="141a69a1e56315315b74c02fdf0f5814.png" width="414" height="72" class="jop-noMdConv"/>
<p>配置文件路径如上所示, 内容如下：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="properties" data-joplin-source-open="```properties&#10;" data-joplin-source-close="&#10;```">customLoadbalance=com.risesun.dubboserverscdemo.CustomLoadbalance</pre><pre class="hljs"><code><span class="hljs-attr">customLoadbalance</span>=<span class="hljs-string">com.risesun.dubboserverscdemo.CustomLoadbalance</span></code></pre></div>
<ol start="3">
<li>获取扩展点实现</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public class Test {
    public static void main(String[] args) {
        LoadBalance loadBalance= ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(&quot;customLoadbalance&quot;);
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        LoadBalance loadBalance= ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(<span class="hljs-string">&quot;customLoadbalance&quot;</span>);
    }
}</code></pre></div>
<h2 id="本质上的作用是什么">本质上的作用是什么？</h2>
<p>根据名字获取扩展点 : 根据名字找对应接口的实现，前提是接口的实现都对应相应的名字，并以某种形式存在，可查询到。
自适应扩展点 : 灵活的根据现有资源(url或者其他实体里面的数据)，进行灵活的自动选择接口的实现；不仅仅是局限在URL，还可以从其他方向入手，例如AdaptiveExtensionFactory, 首先集合所有的ExtensionFacory, 最终通过遍历所有的Factory查找依赖的扩展点实现。
扩展点激活 : 扩展点激活跟URL联系的比较紧密，激活扩展点用于获取一系列的扩展点实现，最终通过限制名称以及group使用范围，来筛选最终选用的扩展点实现， 更像是一种特殊的自适应扩展点。</p>
<p>自适应扩展点像是在自动选择的那一层，再次做可配置化，当我们不知道要使用哪个接口实现的时候，我们可以提供一个自动选取的工具，它可以帮我们去选择。 一般在做到这一层，就结束了，就相当于@Adaptive标记在类上，该类就被当做是写死的类，内部的结构固定了。那如果有新的扩展接口呢？ 如果要根据其他逻辑来判断是否是要选用其中的一个实现类呢？就再写一个该领域的工具？ 我的理解是它提供了@Adaptive注解，可以标记在方法之上，那么其他领域接口需要实现一样逻辑，就可以使用该注解。 这句话有一个重点，就是&quot;一样&quot;，是的，我们看@Adaptive生成的代码的地方:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">if (!&quot;protocol&quot;.equals(value[i])) {
    if (hasInvocation) {
        getNameCode = String.format(&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;, value[i], defaultExtName);
    } else {
        getNameCode = String.format(&quot;url.getParameter(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot;, value[i], defaultExtName);
    }
} else {
    getNameCode = String.format(&quot;( url.getProtocol() == null ? \&quot;%s\&quot; : url.getProtocol() )&quot;, defaultExtName);
}
</pre><pre class="hljs"><code><span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;protocol&quot;</span>.equals(value[i])) {
    <span class="hljs-keyword">if</span> (hasInvocation) {
        getNameCode = String.format(<span class="hljs-string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);
    } <span class="hljs-keyword">else</span> {
        getNameCode = String.format(<span class="hljs-string">&quot;url.getParameter(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);
    }
} <span class="hljs-keyword">else</span> {
    getNameCode = String.format(<span class="hljs-string">&quot;( url.getProtocol() == null ? \&quot;%s\&quot; : url.getProtocol() )&quot;</span>, defaultExtName);
}
</code></pre></div>
<p>dubbo要为所有领域接口提供相应的生成代码的实现，所以，逻辑肯定是一样的， 除非在生成代码地方做判断。可见@Adaptive注解在接口的方法之上使用，有一定的限制的，就是dubbo已经为你准备好了获取方式。我理解的是其灵活度还不够。
就像当我们定义一个App资源位的展示逻辑时，我们需要一个BaseProcessor或者CommonProcessor来为我们的资源位的展示做通用处理。但是如果有其他的非资源位元素呢？我们是否可以通过某种逻辑将这两种元素联系在一起，并且提供抽象层？ 就像dubbo通过url将所有不一类的元素连接在一起。
激活点扩展就像是我们的资源位有很多，但是里面有些是需要登录的用户才能展示，有些是新用户才能展示的。那我们就需要从用户信息里面提取出条件的值，进而和资源位的展示逻辑进行对比，判断是否符合展示条件。</p>
<h2 id="总结">总结</h2>
<p>Dubbo中的扩展点就是通过多种方式去寻找接口的实现。</p>
</div></div>
					</body>
				</html>
			